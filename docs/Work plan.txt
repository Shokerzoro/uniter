0) Веб инфраструктура (в докере):
   -сервер Nginx
   -интерпретатор PHP (для динамического сайта)
   -контейнер с реляционной БД Postgres (для динамического сайта и с внешним Unix сокетом
    для доступа из хоста для основного бэк сервера, пока нет основного сервера)
   -контейнер для получения сертификатов https

   (Реализовано, ожидает получения домена для сертификтов)
	-Получить домен

1) Система обновлений (без авторизации), включает в себя:
   -Демон (в докере), генерирующий файлы .XML с полным описанием deploy директории, снэпы версий.
   -Демон (в докере), поддерживающий сетевой протокол UNET_MES, в рамках которого происходит передача клиентам файлов обновлений.
    Для каждой версии происходит относительное обновление (относительно их версии).
   -Поток в Qt приложении, который общается с сервером по протоколу UNET_MES, выполняющий загрузку обновленных файлов
    либо получающий указание на удаление файлов/каталогов
   -Исполняемый файл updater.exe, выполняющий подмену старых файлов актуальными,
    перенос новых файлов, удаление файлов/каталогов вносит изменения в реестр

   (Реализовано полностью, ожидает тестирования)
   deltametad - поддержка протокола

2) Проектирование UI интерфейса, с реализацией ключевой идеи проекта, расширить протокол UNET-MES для обработки транзакциий

Нужно спроектировать Qt приложение. Оно будет устанавливать SSL соединение с сервером, авторизироваться, после чего запрашивать у сервера файл конфигурации. На основании этого файла будет динамически создаваться виджеты.

1. На счет авторизации. После успешной авторизации клиент будет использовать механизмы ОС для того, чтобы сохранить секретные данные (логин и пароль). Соответственно при запуске он будет выполнять поиск их в хранилище и автоматическую отправку серверу.

2. Установление SSL соединения будет проводится по общепринятому принципу, с моей точки зрения это просто использование функций библиотеки, можно не вдаваться в подробности. А IP адрес соединения будет получаться с помощью DNS запросов по моему домену.

3. Далее, у приложения будет 2 корневых состояния: окно авторизации и основное рабочее окно. При этом состояния будут управляться конечным автоматом основных состояний, и по-сути 3 основными виджетами, которые заключены в центральный.

4. Последнее. После авторизации будет происходить запрос конфигурационного файла от сервера. После его получения основным виджетом будет становиться основное окно. И на основании конфигурационного файла + сохраненных локальных настроек (а как их лучше хранить?) будет производится динамическое построение вкладок, виджетов и т.д. При этом все виджеты в приложении будут делаться на виджеты-контейнеры, которые зависят от конфигурационных файлов, и динамически генерируемые (зависят от локальных настроек). Поэтому каждый виджет-контейнер будет содержать специальный слот-фабрику виджетов динамических.

5. UI виджеты деляться на статические (есть у всех), конфигурационные (находятся в основном виджете, зависят от конфигурации с сервера), и динамические - зависят от локальных настроек

На счет порядка создания виджетов. Сначала создается mainwindow и другие статические виджеты, и класс конечного автомата (основного),
Они все находятся в иерархии, до корневого mainwindow. 
Потом mainwindow создает менеджерские QObject, один для работы с локальными настройками, другой для связи с основным сервером, другой для получения обновлений (параллельно).
После создания QObject для связи с основным сервером - ищет логин/пароль, делает DNS запросы по домену, отправляет запрос на авторизацию.
После успешной авторизации он отправляет запрос на получение конфигурации, после получения отправляет сигнал об успешном подключении.
При этом основной конечный автомат переводится на рабочее окно, рабочее окно начинает парсить конфигурационный файл, после чего обращается к QObject локальных настроек, 
последний начинает читать локальные настройки и генерировать сигналы для создания динамических виджетов. 

Сигналы для создания динамических виджетов на самом деле принимают соответствующие виджеты контейнеры внутри главного окна.
Каждый такой виджет-контейнер обладает своей машиной состояния (конечным автоматом), чтобы уже только внутри себя отслеживать изменения.

Также после успешной авторизации начинает работать параллельно сервер для получения обновлений (точнее QObject)
Как происходит отправка унифицированых сообщений-действий серверу?
Я думаю что сообщение по отправки данных должно проходить иерархически через видждеты до объекта, отвечающего за сервер.
Каждый слой будет заполнять только свои поля.

3) Разработка потока для связи с основным сервером (бэкэндом), который должен поддерживать
   -шифрование
   -аутентификацию (возможно какие то Coockie для по аналогии с http)
   -получение/передачу порций данных в виде транзакциий (подтверждение выполнения)

4) Разработка основного бэк сервера (в докере), который поддерживает
   -шифрование
   -аутентификацию (возможно какие то Coockie для по аналогии с http)
   -взаимодействие с БД
   -получение/передачу порций данных в виде транзакциий
   -минимальное логирование
   -интеграция с существующей докер инфраструктурой

5) Проектирование БД, которая должна обеспечивать
   -
   -
   -
   -

6) Написание фронта (обвязка над UI, формирование и отправка сообщений серверу)

7) Написание бэка (обработка сообщений и отправка ответов)

8) Создание сайта с возможностью регистрации, оплаты, обратной связи и проч.

9)Юридическая часть: регистрация фирмы, открытие счетов, получение кодов ОКВЭД, юридического адреса.
  Составление договоров

На будущее:
 - Возможно стоит сделать более мягкое завершение сокета в приложении.
 - Сделать блокирование файлов на fullmetad демоне, когда он получает обновление (чтобы не отправлять новые файлы устаревшим клиентам)
 - В deltametad сделать ограничение на кол-во потоков в один момент.
 - Сделать recover.exe и журналирование в Updater при замене/удалении/добавлении файлов апдейтером, чтобы была возможность откатиться обратно.
   Причем журналирование лучше сделать до первого реального релиза
   А на запуск recover.exe можно поставить заглушку, чтобы пока его нет, он бы не запускался. Проверка recover.exe в main апдейтера



Что необходимо еще подучить?

SQL Реляционные базы данных Куликов Святосла
реляционное проектирование, нормализацию данных и индексацию

